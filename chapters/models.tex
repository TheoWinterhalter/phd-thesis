% \setchapterpreamble[u]{\margintoc}
\chapter{Models of type theory}
\labch{models}

Justifying a logic is often achieved using \emph{models}. A model consists
in giving an interpretation to all constructs of the logic we want to study,
such that its rules are still verified.
There are several ways to get models of type theory, I will present some of the
most common ones in this chapter, though my means of choice will presented in
depth in \nrefch{translations}.

\section{What is a model?}

A model of type theory is an interpretation of the concepts of a type theory
into another theory or object, both living in the same meta-theory.
\begin{figure}[hb]
  \includegraphics[width=0.9\textwidth]{model}
\end{figure}
To be more precise, a model is given by a class of objects to interpret
contexts, one for terms and one for types; but a model also provides an
interpretation to judgments in such a way that the interpretation is coherent.

\subsection{What can be proved using models}

\paragraph{Consistency.}

I already briefly mentioned this but the main point of models is to prove
consistency of a theory, relying on the already \emph{known} consistency of the
theory in which lives the model... At least in principle. It is however very
rare\sidenote{Impossible?} to \emph{know} that a theory is consistent, instead
we should see it as a theory we \emph{trust}, typically a theory that's widely
accepted as beeing consistent by the community of mathematicians.
This also applies to the meta-theory in which we show that the interpretation is
correct. As such it is best to keep it as simple as possible to avoid relying on
the consistency of too complicated objects.

\paragraph{Independence.}

Another interesing application of models is showing \emph{independence} of a
proposition.

\begin{definition}[Independent proposition]
  A proposition \(P\) is said to be independent from a theory \cT when neither
  \(P\) nor \(\neg P\) can be proven within \cT.
\end{definition}

A way to prove that some \(P\) is independent from \cT is to give a model of \cT
which validates \(P\) and another model which invalidates it (or validates
\(\neg P\)). Indeed if any one of \(P\) or \(\neg P\) %, let's say \(P\),
could be proven in \cT, then it would be valid in both models, leading to
at least one of them being inconsistent.

The fact that a proposition can neither be validated or invalidated in a theory
can come as surprising for some, especially in a classical mindset.
\reminder[-1.8cm]{Classical logic}{
  Classical logic is often characterised by the presence of the \acrshort{LEM}
  which consists in a proof of \(A \vee \neg A\).
}
Gödel's incompleteness theorems have to do with this.

\subsection{Gödel's incompleteness theorems}

\todo{Is it really the place? Should it even go in the proof theory chapter?}

\section{Set-theoretic models}

Set-theoretic models are models of type-theory where types are interpreted as
sets. For instance the type \(A \to B\) will be interpreted as the set of
set-theoretic functions from the interpretation of \(A\) to the interpretation
of \(B\):
\marginnote[0.2cm]{
  It is usual to write \(\transl{A}\) for the interpretation of \(A\).
}
\[
  \transl{A \to B} \coloneqq \setfun{\transl{A}}{\transl{B}})
\]
\todo{I'm missing a ref here on how to do this...}

\section{Categorical models}

Categorical models are one of the most used way of defining models for type
theories. There are several notions of categorical models:
contextual categories~\sidecite[-0.9cm]{cartmell1986generalised} from which stem
categories with attributes~\sidecite[0.2cm]{hofmann1994interpretation} and
C-systems~\sidecite[0.9cm]{voevodsky2016subsystems},
\acrfullpl{CwF}~\sidecite[1.7cm]{dybjer1995internal}, and more\dots
I will focus on \acrshortpl{CwF} in this document.

\subsection{Categories with families}

A \acrshort{CwF} is given by
\begin{enumerate}
  \item a collection of objects (or contexts) \(\Con\);
  \item morphisms (or substitutions) \(\sigma : \Ga \to \D\) between contexts
  \(\Ga, \D : \Con\);
  \item for each context \(\Ga : \Con\), a collection \(\CTy\ \Ga\) of types in
  that context;
  \item for each context \(\Ga : \Con\) and type \(A : \CTy\ \Ga\), a collection
  \(\CTm\ \Ga\ A\) of terms of type \(A\);
  \item an operation of substitution for types taking \(\sigma : \Ga \to \D\)
  and a type \(A : \CTy\ \D\) to type \(A[\sigma] : \CTy\ \Ga\);
  \item \label{item:term-subst} a similar substitution operation on terms taking
  \(\sigma : \Ga \to \D\) and a term \(t : \CTm\ \D\ A\) to term
  \(t[\sigma] : \CTm\ \Ga\ A[\sigma]\);
  \item a terminal object representing the empty context \(\ctxempty : \Con\);
  \item an extension operation taking \(\Ga : \Con\) and \(A : \CTy\ \Ga\)
  to a new object \(\Ga, A : \Con\) together with a morphism
  \(\pp : \Ga, A \to \Ga\) and a term \(\pq : \CTm\ (\Ga, A)\ A[\pp]\);
  \item an operation taking \(\sigma : \Ga \to \D\) and term
  \(a : \CTm\ \Ga\ A[\sigma]\) to substitution \(\sigma, a : \Ga \to \D, A\)
  such that \(\pp \circ (\sigma, a) = \sigma\) and \(\pq[\sigma, a] = a\).
\end{enumerate}
The two first have to give the structure of category, this in particular means
that there is an identity substitution, and associative composition of those.

The category \(\Set\) of sets is a \acrshort{CwF}:
\marginnote[3.8cm]{
  \ref{item:term-subst} holds because for every \(\gamma \in \Ga\),
  \[
    (t \circ \sigma)(\gamma) = t(\sigma(\gamma)) \in A_{\sigma(\gamma)}
    = A[\sigma]_\gamma
  \]
}
\begin{enumerate}
  \item objects are sets;
  \item substitutions are given as set-theoretic functions, composed as
  functions;
  \item types in \(\CTy\ \Ga\) are sets indexed by \(\Ga\);
  \item terms of \(\CTm\ \Ga\ A\) are choice functions
  \(t \in \setfun{\Ga}{\bigcup_{\gamma \in \Ga} A_\gamma}\) such that
  \(t(\gamma) \in A_\gamma\) for every \(\gamma \in \Ga\);
  \item given \(\sigma : \Ga \to \D\) and \(A : \CTy\ \D\), \(A[\sigma]\)
  is defined as the \(\Ga\)-index family \((A_{\sigma(\gamma)})_\gamma\);
  \item given \(\sigma : \Ga \to \D\) and \(t : \CTm\ \D\ A\), \(t[\sigma]\)
  is defined as the choice function \(t \circ \sigma\);
  \item the empty context is given as the singleton \(\{ \emptyset \}\);
  \item given \(\Ga : \Con\) and \(A : \CTy\ \Ga\), \(\Ga, A\) is defined as
  the disjoint union \(\amalg_{\gamma \in \Ga} A_\gamma\), \(\pp\) and \(\pq\)
  are defined as the first and second projection respectively;
  \item given \(\sigma : \Ga \to \D\) and \(a : \CTm\ \Ga\ A[\sigma]\),
  \(\sigma, a\) is defined as the function
  \(\gamma \mapsto (\sigma(\gamma), a)\) which verifies the conditions.
\end{enumerate}

Right now this only interprets a type theory with no type or term constructors.
I will give a few example of those.

\paradot{Dependent products}

A \acrshort{CwF} is said to have dependent products when it has the following
elements:
\begin{itemize}
  \item for any \(A : \CTy\ \Ga\) and \(B : \CTy\ (\Ga, A)\) there exists
  \(\Pi\ A\ B : \CTy\ \Ga\);
  \item for \(b : \CTm\ (\Ga, A)\ B\) there exists
  \(\lambda b : \CTm\ \Ga\ (\Pi\ A\ B)\);
  \item for \(f : \CTm\ \Ga\ (\Pi\ A\ B)\) and \(u : \CTm\ \Ga\ A\) there exists
  \(\capp(f,u) : \CTm\ \Ga\ B[\cid, u]\)
\end{itemize}
such that for any \(\sigma : \D \to \Ga\) and terms and types as above the
following equations hold:
\[
  \begin{array}{rcl}
    (\Pi\ A\ B)[\sigma] &=& \Pi\ A[\sigma]\ B[(\sigma \circ \pp), \pq] \\
    (\lambda b)[\sigma] &=& \lambda b[(\sigma \circ \pp), \pq] \\
    (\capp(f,u))[\sigma] &=& \capp(f[\sigma],u[\sigma]) \\
    \capp(\lambda b, u) &=& b[\cid, u] \\
    \lambda \capp(f \circ \pp, \pq) &=& f
  \end{array}
\]

\sidedef[-0.7cm]{\(\eta\)-expansion}{
  \(\eta\)-expansion is defined as follows
  \[
    t \red_\eta \lambda x.\ t\ x
  \]
  \(\eta\)-contraction is the opposite relation.
}
The four first equations are simply there to attest to the good behaviour of
substitution. The last two are more interesting, corresponding to
\(\beta\)-reduction and \(\eta\)-contraction respectively.

\paradot{Dependent sums}

A \acrshort{CwF} has (negative\sidenote{See \nrefch{flavours}.}) dependent sums
when:
\begin{itemize}
  \item for any \(A : \CTy\ \Ga\) and \(B : \CTy\ (\Ga, A)\) there exists
  \(\Sigma\ A\ B : \CTy\ \Ga\);
  \item for \(a : \CTm\ \Ga\ A\) and \(b : \CTm\ \Ga\ B[\cid,a]\) there exists
  the dependent pair \(\dpair{a,b} : \CTm\ \Ga\ (\Sigma\ A\ B)\);
  \item for \(p : \CTm\ \Ga\ (\Sigma\ A\ B)\) there exists
  \(\pi_1\ p : \CTm\ \Ga\ A\);
  \item for \(p : \CTm\ \Ga\ (\Sigma\ A\ B)\) there exists
  \(\pi_2\ p : \CTm\ \Ga\ B[\cid, \pi_1\ p]\)
\end{itemize}
such that
\[
  \begin{array}{rcl}
    (\Sigma\ A\ B)[\sigma] &=& \Sigma\ A[\sigma]\ B[(\sigma \circ \pp), \pq] \\
    \dpair{a,b}[\sigma] &=& \dpair{a[\sigma], b[\sigma]} \\
    (\pi_1\ p)[\sigma] &=& \pi_1\ p[\sigma] \\
    (\pi_2\ p)[\sigma] &=& \pi_2\ p[\sigma] \\
    \pi_1\ \dpair{a,b} &=& a \\
    \pi_2\ \dpair{a,b} &=& b
  \end{array}
\]

\paradot{Identity types}

A \acrshort{CwF} has identity types---another name for the equality type---when:
\begin{itemize}
  \item for \(A : \CTy\ \Ga\) and \(u, v : \CTm\ \Ga\ A\) there exists
  \(\CId_A\ u\ v : \CTy\ \Ga\);
  \item for \(A : \CTy\ \Ga\) and \(u : \CTm\ \Ga\ A\) there exists
  \(\crefl_u : \CTm\ \Ga\ (\CId_A\ u\ u)\)
\end{itemize}
such that
\[
  \begin{array}{rcl}
    (\CId_A\ u\ v)[\sigma] &=& \CId_{A[\sigma]}\ u[\sigma]\ v[\sigma] \\
    (\crefl_a)[\sigma] &=& \crefl_{a[\sigma]}
  \end{array}
\]
In a lot of models, equality end up being interpreted as the equality of the
model meaning the eliminator is not necessary, hence my not requiring it.

\paradot{Booleans}

A \acrshort{CwF} has booleans when for any \(\Ga : \Con\) it has
\begin{itemize}
  \item \(\bool : \CTy\ \Ga\);
  \item \(\ttrue : \CTm\ \Ga\ \bool\);
  \item \(\ffalse : \CTm\ \Ga\ \bool\);
  \item given \(b : \CTm\ \Ga\ \bool\), \(C : \CTy\ (\Ga, \bool)\),
  \(t : \CTm\ \Ga\ C[\cid, \ttrue]\) and \(f : \CTm\ \Ga\ C[\cid, \ffalse]\),
  some \(\tif{b}{C}{t}{f} : \CTm\ \Ga\ C[\cid, b]\)
\end{itemize}
such that
\[
  \begin{array}{rcl}
    \bool[\sigma] &=& \bool \\
    \ttrue[\sigma] &=& \ttrue \\
    \ffalse[\sigma] &=& \ffalse \\
    \left(\fitif{b}{C}{t}{f}\right)[\sigma] &=&
    \fitif{b[\sigma]}{C[(\sigma \circ \pp), \pq]}{t[\sigma]}{f[\sigma]} \\
    \tif{\ttrue}{C}{t}{f} &=& t \\
    \tif{\ffalse}{C}{t}{f} &=& f
  \end{array}
\]

\paradot{Natural numbers}

A \acrshort{CwF} has natural numbers when, given \(\Ga : \Con\), it has
\marginnote[0.1cm]{
  For the successor I use \(\Pi\)-types when I could have instead put things
  in the context. Both are valid and I'm often favorable to the idea that things
  should be kept separate as much as possible, but the reliance on application
  and everything allows us to avoid proving the same things several times,
  especially since manipulating contexts is so tedious with categories.
}
\begin{itemize}
  \item \(\nat : \CTy\ \Ga\);
  \item \(\czero : \CTm\ \Ga\ \nat\);
  \item for \(n : \CTm\ \Ga\ \nat\), \(\csucc\ n : \CTm\ \Ga\ \nat\);
  \item for \(n : \CTm\ \Ga\ \nat\), \(C : \CTy\ (\Ga, \nat)\),
  \(z : \CTm\ \Ga\ C[\cid, \czero]\) and
  \(s : \CTm\ \Ga\ (\Pi\ \nat\ \Pi\ C\ C[(\pp, \csucc\ \pq) \circ \pp])\),
  there exists \(\natrec_C\ n\ z\ s : \CTm\ \Ga\ C[\cid, n]\)
\end{itemize}
such that
\[
  \begin{array}{rcl}
    \nat[\sigma] &=& \nat \\
    \czero[\sigma] &=& \czero \\
    (\csucc\ n)[\sigma] &=& \csucc\ n[\sigma] \\
    (\natrec_C\ n\ z\ s) &=&
    \natrec_{C[(\sigma \circ \pp), \pq]}\ n[\sigma]\ z[\sigma]\ s[\sigma] \\
    \natrec_C\ \czero\ z\ s &=& z \\
    \natrec_C\ (\csucc\ n)\ z\ s &=& \capp(\capp(s,n), \natrec_C\ n\ z\ s)
  \end{array}
\]

\paradot{Tarski universes}

A Tarski universe is given by
\begin{itemize}
  \item a type in the empty context \(\CU : \CTy\ \ctxempty\);
  \item a type family \(\CEl : \CTy\ (\ctxempty, \CU)\);
  \item a function
  \(\pi \in \setfun{\amalg_{a \in \CU} \CU^{\CEl[\cid, a]}}{\CU}\)
\end{itemize}
such that
\[
  \begin{array}{rcl}
    \CU[\sigma] &=& \CU \\
    \CEl[\cid, \pi(a,b)] &=& \Pi\ \CEl[\cid, a]\ \CEl[\pp, b(\pq)]
  \end{array}
\]
This makes the universe closed under dependent types, we can of course extend
this notion to include other constructions.

All of these can be defined in the \(\Set\) model above. They are however all
simpler cases than the \(\Card\) model I will give in the next section so I
won't detail them.

\subsection{Cardinal model}

\section{Type-theoretic models}

\todo{Cat models fall in this too}
\todo{translations, syntactical models, standard model}