% \setchapterpreamble[u]{\margintoc}
\chapter{Well-founded induction and well-orders}
\labch{coq-orders}

This chapter is perhaps a bit off-track compared to the others in this chapter
as it is a bit general but I have it here because I am going to rely on it in
the next chapters.

\section{General setting}

The \emph{classical} definition of a well-founded order basically says that one
cannot \emph{go down} indefinitely in that order.

\begin{definition}[Well-order (classically)]
  An order \(\prec\) is said to be well-founded when there is not infinitely
  decreasing sequence for that order, \ie there is no sequence
  \((u_i)_{i \in \mathbb{N}}\) such that for all \(i\), \(u_{i+1} \prec u_i\).
\end{definition}

When \(\prec\) is a well-order, every non-increasing sequence has to become
stationary at some point.
The prototypical example of this the canonical order on \(\mathbb{N}\): if you
take a natural number and start going down, at some point you have to stop lest
you go below \(0\) and leave the realm of natural numbers.
We say that \(\mathbb{N}\) is a well-founded set in that case.

This is particularly useful to show that a process terminates. If after
completing each task you are left with the completion of smaller tasks,
you will eventually run out of tasks to complete.
This can be used to justify the termination of an \ocaml function like the
ever-famous factorial function.
\marginnote[0.5cm]{
  Even though the \ocaml \mintinline{ocaml}{int} type is not comprised only of
  natural numbers, the \mintinline{ocaml}{n < 1} condition ensures that the
  recursive call only happens when \(n \ge 1\).
}
\begin{minted}{ocaml}
let rec fact n =
  if n < 1
  then 1
  else n * (fact (n - 1))
\end{minted}
The recursive call is always on a smaller natural number and at some point it
will reach some \(n < 1\) and return a value.

This kind of reasoning is the key to proofs of termination in general, but this
presentation is not really suited to a constructive setting like \Coq because of
the negative formulation.

\section{Constructive setting}

In an intuitionistic or even constructive setting, the notion of
well-foundedness is stated in a positive way: instead of saying the there is no
infinitely decreasing sequence, we say that every element---for instance every
natural number---is \emph{reachable} in a finite number of steps from the base
case(s).

\begin{definition}[Accessibility]
  A term \(t\) of type \(A\) is accessible for a relation \(\prec\) on \(A\)
  when all smaller elements for \(\prec\) are also accessible.
\end{definition}
\marginnote[-1.3cm]{
  In particular, a minimal element---in the sense that there are no \(u\) such
  that \(u \prec t\)---is always accessible.
}

For instance, to show that \(2\) is accessible for \(<\) we would need to show
that \(0\) and \(1\) are accessible, and for \(1\) we would need to show that
\(0\) is accessible. This leaves us with \(0\). It is accessible because there
are no smaller natural numbers. \(0\) is the base case.

\marginnote[0.1cm]{
  Note that we define well-founded relations and not well-orders, this is more
  general and actually sufficient for us. A well-order is an order that forms a
  well-founded relation.
}
\begin{definition}[Well-founded relation]
  A relation \(\prec\) on \(A\) is well-founded when all the inhabitants of
  \(A\) are accessible for \(\prec\).
\end{definition}

Again, this is the case that all natural numbers are accessible for \(<\)
and this can be shown by induction.
From this we can do well-founded induction: if a property holds for \(t\) when
it holds for smaller elements, it holds for every accessible element.

In \Coq the accessibility predicate is defined as follows:
\begin{minted}{coq}
Inductive Acc (A : Type) (R : A -> A -> Prop) (x : A) : Prop :=
  Acc_intro : (forall y : A, R y x -> Acc R y) -> Acc R x
\end{minted}
This corresponds to a translation of the definition above to the syntax of \Coq.
The induction principle produced by \Coq for \mintinline{coq}{Acc} yields
well-founded induction.
\begin{minted}{coq}
Acc_ind :
  forall (A : Type) (R : A -> A -> Prop) (P : A -> Prop),
    (forall x : A,
      (forall y : A, R y x -> Acc R y) ->
      (forall y : A, R y x -> P y) ->
      P x
    ) ->
    forall x : A, Acc R x -> P x
\end{minted}
It says that if for any given \(x : A\) such that all \(y : A\) smaller than
\(x\) are accesible and verify the predicate \(P\), \(x\) also verifies \(P\),
then all accessible elements verify \(P\).

\reminder[-0.7cm]{Fibonacci sequence}{
  The Fibonacci sequence \((\mathcal{F}_n)_{n \in \mathbb{N}}\) is defined by
  \(\mathcal{F}_0 = 0\), \(\mathcal{F}_1 = 1\) and
  \(\mathcal{F}_{n+2} = \mathcal{F}_{n+1} + \mathcal{F}_n\).
}
Let's say this time we want to define the Fibonacci sequence, the following
definition isn't accepted by \Coq's termination checker.
\begin{minted}{coq}
Fail Fixpoint fib n :=
  match n with
  | 0 => 1
  | 1 => 1
  | S (S n) => fib (S n) + fib n
  end.
\end{minted}
It doesn't like the \mintinline{coq}{S n} bit in the recursive call.
I'm cheating a bit because it can still be defined by telling \Coq that
\mintinline{coq}{S n} here is indeed a subterm of the matched term.
\begin{minted}{coq}
Fixpoint fib n :=
  match n with
  | 0 => 1
  | 1 => 1
  | S ((S n) as m) => fib m + fib n
  end.
\end{minted}
\marginnote[0.2cm]{
  If you're not convinced by this argument, just read the rest of the thesis
  to see well-founded induction in action.
}
For the sake of the argument I will still write this function using well-founded
induction.
\begin{minted}{coq}
Require Import Lia Arith.

Lemma wf_nat :
  well_founded lt.
Proof.
  intro n. induction n as [| n ih].
  - constructor. intros m h. lia.
  - constructor. intros m h.
    destruct (eq_nat_dec m n).
    + subst. assumption.
    + destruct ih as [ih]. apply ih. lia.
Qed.

Definition fib n :=
  Acc_rec (fun _ => nat)
    (fun n =>
      match n with
      | 0 => fun _ _ => 1
      | 1 => fun _ _ => 1
      | S (S m) =>
        fun acc_lt_n fib_lt_n =>
          fib_lt_n (S m) (Nat.lt_succ_diag_r (S m)) +
          fib_lt_n m
            (Nat.lt_trans _ _ _
              (Nat.lt_succ_diag_r m)
              (Nat.lt_succ_diag_r (S m)))
      end
    )
    (wf_nat n).
\end{minted}
\marginnote[-9.8cm]{
  \mintinline{coq}{well_founded R} is defined as
  \mintinline{coq}{forall x : A, Acc R x} for
  \mintinline{coq}{R : A -> A -> Prop}.
  Also \mintinline{coq}{n < m} is just a notation for
  \mintinline{coq}{lt n m}.
}
The \mintinline{coq}{fib} function we try to define earlier is barely
recognisable here. Fortunately for us there are tools to write well-founded
inductions in a nicer way. One such tool is \Equations.
\begin{minted}{coq}
From Equations Require Equations.

Equations fib (n : nat) : nat
  by wf n lt :=

  fib 0 := 1 ;
  fib 1 := 1 ;
  fib (S (S n)) := fib (S n) + fib n.
\end{minted}
The syntax differs a bit from vanilla \Coq but should be pretty
self-explanatory. We write the function just the way we want it to be and
specify that we are using well-founded recursion on \mintinline{coq}{n}
using the standard \mintinline{coq}{lt} order with \mintinline{coq}{by wf n lt}.
Then it generates some proof obligations saying that the recursive calls are
indeed made on smaller arguments for \mintinline{coq}{lt}, but as they are
pretty simple, it solves them for us.
Moreover it uses the type-class mechanism to automatically find a proof that
the order is indeed well-founed.
Thanks to \Equations, well-founded recursion is not too painful and pretty
useful.

\section{Lexicographic orders}

I will dedicate this section to a special case of order that will be useful for
the formalisation.

\subsection{Simple lexicographic orders}

Generally speaking, a lexicographic order is the combination of two orders to
yield an order on pairs. The alphabetical order is one instance of lexicographic
order: you first compare the first letter of each word, and if they match you
proceed to the second, etc.

\begin{definition}[Lexicographic order]
  Given two types \(A\) and \(B\) and two orders \(\prec_A\) and \(\prec_B\)
  on them, the lexicographic order \(\prec_{\mathsf{lex}}\) on \(A \times B\)
  is defined as
  \[
    (a,b) \prec_{\mathsf{lex}} (a',b')
    \text{ when }
    \left\{
    \begin{array}{ll}
      \text{either} & a \prec_A a' \\
      \text{or} & a = a' \text{ and } b \prec_B b'
    \end{array}
    \right.
  \]
\end{definition}

So, like the alphabetical order, when the two first elements are in the
relation, we won't even look at the rest.
\marginnote[0.2cm]{
  They also remain orders.
}
This is pretty convenient, especially since lexicographic orders preserve
well-foundedness.

\begin{lemma}[Well-founded lexicographic orders]
  If \(\prec_A\) and \(\prec_B\) are both well-founed, then the lexicographic
  order they induce is also well-founded.
\end{lemma}

\todo{Some example of program?}

In the context of dependent types, these might not prove sufficient, hence the
need for dependent lexicographic orders.

\subsection{Dependent lexicographic orders}

In the same way that simple products \(A \times B\) can be extended to their
dependent counterpart \(\Sigma\)-types: \(\Sigma (x:A). B\), lexicographic
orders have a dependent version.
As before, we take an order \(\prec_A\) on \(A\), but as \(B\) depends on
\(x : A\), we need the second order to also depend on \(x\). Fortunately for us,
the only times we're interested in \(\prec_B\) is when the first two components
are the same (\(a = a'\)), meaning the same type \(B[x \sto a]\).

\marginnote[2.6cm]{
  Notice in the second case that there is no \(a'\), it's twice \(a\).
}
\begin{definition}[Dependent lexicographic order]
  Given a type \(A\) and a type \(B\) dependent on \(A\), as well as an order
  \(\prec_A\) on \(A\) and an order \(\prec_B\) on \(B\), dependent on \(A\),
  we define their dependent lexicographic order on \(\Sigma (x:A). B\),
  \(\prec_{\mathsf{lex}}\) as
  \[
    \begin{array}{lcl}
      \dpair{a,b} \prec_{\mathsf{lex}} \dpair{a',b'} &\text{when}&
      a \prec_A a' \\
      \dpair{a,b} \prec_{\mathsf{lex}} \dpair{a,b'} &\text{when}&
      b \prec_{B[x \sto a]} b'
    \end{array}
  \]
\end{definition}

I find the \Coq definition can shed more light than the paper one in this case.
In it the dependencies appear in a more explicit manner so it can lift some
confusion I hope.

\begin{minted}{coq}
Inductive dlexprod {A} {B : A -> Type}
  (leA : A -> A -> Prop) (leB : forall x, B x -> B x -> Prop)
  : sigT B -> sigT B -> Prop :=

| left_lex :
    forall x x' y y',
      leA x x' ->
      dlexprod leA leB (x;y) (x';y')

| right_lex :
    forall x y y',
      leB x y y' ->
      dlexprod leA leB (x;y) (x;y').
\end{minted}
\marginnote[-1cm]{
  In \Coq I write \mintinline{coq}{(x;y)} for \(\dpair{x,y}\).
}

I use notations for the simple and dependent lexicographic orders:
\begin{minted}{coq}
Notation "R1 ⊗ R2" :=
  (lexprod R1 R2)
  (at level 20, right associativity).

Notation "x ⊩ R1 ⨶ R2" :=
  (dlexprod R1 (fun x => R2))
  (at level 20, right associativity).
\end{minted}

Once again, the dependent lexicographic order of two well-founded orders is also
well-founded. In \Coq I show something even more precise, saying that a pair
\(\dpair{x,y}\) is accessible if \(x\) is accessible and the second order is
well-founded.
\begin{minted}{coq}
Lemma dlexprod_Acc :
  forall A B leA leB,
    (forall x, well_founded (leB x)) ->
    forall x y,
      Acc leA x ->
      Acc (@dlexprod A B leA leB) (x;y).
\end{minted}

\todo{Maybe an example of usage?}

\subsection{Lexicographic order modulo a bissimulation}

With usual lexicographic orders, the second order is involved with the first
components are \emph{equal}. In some cases, this requirement is just too strong
and we want to relax it a bit, by accepting them to be equal modulo another
relation. Of course we cannot accept any relation, otherwise we would have no
hope of showing the resulting order well-founded.