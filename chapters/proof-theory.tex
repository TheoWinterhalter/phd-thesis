% \setchapterpreamble[u]{\margintoc}
\chapter{Proof theory}
\labch{proof-theory}

My work is done in the wide domain of proof theory. Proof theorists are
interested in the way to prove things, in the `proof' object itself.
This allows us to understand more about proof reuse, about transposition of a
property to another system, or about some intrinsinc properties of the proof
itself. The study of proofs also allows to define clear systems outlining
formally what a proof is and when it is valid. This leads to the notion of
certificate that one can check independently. The epitome of this is the ability
to write proofs that are checkable by a computer, shifting the trust one needs
to put within every proof, to the system which validates them all.

\section{How to prove something}

\subsection{A social construct?}

Before we start proving something, we must know percisely what it is we want to
prove. In informal mathematics, the statement will be a sentence, involving
concepts that the writer and reader agree on. The proof then consists in a
sequence of sentences and argument that convince the same readers.

With this definition, a proof is a subjective concept, it depends on the
reader's capacity to understand and potentially fill the gap themselves about
understood statements and properties. It also involves a fair bit of
\emph{trusting} usually: you may not understand a proof, but will believe in
the common effort of the community to verify the proof or, even better,
reproduce it.
As such, \emph{consensus} seems key in the scientific community.

One way to reach consensus much faster is to have statements and proofs really
precise and unambiguous, described in formal systems. This approach still has
shortcomings, will all readers check every tiny detail of the proof once it's
laid out extensively? This poses the risk of having the \emph{idea} lost in a
sea of information.
To me this calls for computer-verified proofs---and maybe even automated or
computer aided proofs---so that the reader can focus on the interesting part of
the proof while trusting only the tool and not the human that used it.

Even there is room for question on whether this really constitutes a proof.
For instance, how \emph{hard} is it for the computer to \emph{see} that the
proof is indeed correct? One definition would be to say, as long as it takes
a finite amount of time, it's good, but if it takes ages, we won't have any
certainty. In \sidecite{de1991plea}, de Bruijn suggests that a proof should be
self-evident. You shouldn't have to think for hours before seeing that is indeed
correct, and the same holds for computers.

In the remainder of the section I will address the way we \emph{write}
statements and proofs.

\subsection{Formal statements}

\marginnote[0.2cm]{
  Since I want to be as general as possible, this talk about formal statements
  will be pretty informal.
}
What do formal statements look like? Probably something like
\[
  \forall n \in \mathbb{N}. \exists m \in \mathbb{R}.
  f(n) = \mathsf{e}^{\phi(m)} \wedge g(n) > m
\]
It involves defined symbols, and logical connectives to make something precise.
In particular you will not the universal (\(\forall\)) and existential
(\(\exists\)) quantifiers, equality (\(=\)), logical conjunction (\(\wedge\))
and a comparison operator (\(>\)).
We can assume \(\mathbb{N}\), \(\mathbb{R}\), \(f\), \(g\), \(h\), \(\phi\) and
\(e\) to be defined prior to the statement (using similar formalism).

To define this, we give a syntax of propositions, mutually with a syntax of
sets on which we want to quantify. Because equality can mention elements however
we also have to provide a syntax for those, and maybe one for function symbols.
\[
  \begin{array}{rrl}
    P, Q &\bnf& \top \bnfor \bot \bnfor P \wedge Q \bnfor P \vee Q \\
    &\bnfor& \forall x \in E. P \bnfor \exists x \in E. P \bnfor u = v \\
    E &\bnf& \mathbb{N} \bnfor \mathbb{R} \bnfor \dots \\
    u, v &\bnf& x \bnfor \mathsf{e}^u \bnfor u + v \bnfor f(u) \bnfor \dots \\
    f, g, h &\bnf& \dots
  \end{array}
\]

Coming up with a correct syntax like those can be pretty painful so formalisms
tend to be as minimal as possible, the other advantage being that is much easier
to reason on the statements when there aren't hundreds of syntactical
constructs.

Of course, giving a syntax of statements is not enough. We must give these
symbols a semantics to know what it means to prove them.

\subsection{Inference rules}

\todo{Talk about the three implications, \(\to\), \(\vdash\) and inference
rules}

\section{Proof frameworks}

\todo{Different logics, Constructiveness, classical logic, linear logic}
\todo{mechanised proofs, proof assistants, automated theorem provers}