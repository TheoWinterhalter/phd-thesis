% \setchapterpreamble[u]{\margintoc}
\chapter{Conversion}
\labch{coq-conversion}

We want to implement a correct conversion checker that is close enough to the
actual implementation that is rather efficient, instead of the naive solution
of reducing both terms to normal forms and then comparing them syntactically.
We also have to take care of universes and cumulativity which complicates matter
a little bit.

\section{High level description}

I will present our approach at the high level.
\begin{enumerate}[label=(\arabic*)]
  \item \label{itm:convred} First we weak head reduce the two terms without
  \(\delta\)-reduction (\ie without unfolding definitions);
  \item then we compare their heads, if they match we begin again at
  \ref{itm:convred};
  \item if they do not match, we check if some computation (pattern-matching
  or fixed-point)---or even the whole term---is blocked by a definition that
  could unfold to a value, and if so we unfold the definition and start again.
\end{enumerate}

Following reduction, we actually use terms versus stacks to deal with focusing.
Conversion is in fact split in four main phases that I codify as follows
\begin{itemize}
  \item \mintinline{coq}{Reduction} which corresponds to putting the two terms
  in weak head normal forms;
  \item \mintinline{coq}{Term} which corresponds to comparing the heads of the
  focused terms;
  \item \mintinline{coq}{Args} which corresponds to comparing the arguments
  on the stacks;
  \item \mintinline{coq}{Fallback} which happens when comparing different heads
  and we attempt to reduce both sides a bit more.
\end{itemize}
These roughly correspond each to one of the mutual definitions that yield
conversion. I will write these functions as judgements:
\marginnote[0.5cm]{
  Here I forget about the typing requirements, but conversion, like reduction,
  can only operate on well-typed terms.
}
\[
  \begin{array}{c}
    \isconv{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}
  \end{array}
\]
where \(A\) is the \emph{answer} which is basically `yes' or an error message.
\(A\) is the \emph{output} while everything else is the \emph{input}.
I will use the subscripts \(\cred\), \(\cterm\), \(\cargs\) and \(\cfall\)
to diffrenciate the four phases.
I will present them in more depth so that we can see what are
the requirements for termination.

\subsection{\mintinline{coq}{Reduction}}

The first phase takes two pairs of term and stack and reduce both using the
weak head reduction machine of \nrefch{coq-reduction}.
In order to avoid unfolding definitions unnecessarily, we disable the
\(\delta\)-reduction.
% This means that we pass the
% \begin{minted}{coq}
% RedFlags.nodelta
% \end{minted}
% flags to the machine.
This means that we pass the \mintinline{coq}{RedFlags.nodelta} flags to the
machine.

I will once again describe these functions and their recursive calls using
inference rules for simplicity.
\begin{mathpar}
  \infer
    {
      \Ga \vdash \vscmd{t_1}{\pi_1} \red_{\WM \not\delta} \vscmd{u_1}{\rho_1} \\
      \Ga \vdash \vscmd{t_2}{\pi_2} \red_{\WM \not\delta} \vscmd{u_2}{\rho_2} \\
      \convterm{\Ga}{u_1}{\rho_1}{u_2}{\rho_2}{A}
    }
    {\convred{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
  %
\end{mathpar}
Here we simply do a recursive call on the weak head normal forms of the two
inputs.

\subsection{\mintinline{coq}{Term}}

For this phase, we take two inputs that are in weak head normal form (without
\(\delta\)-reduction) and look at the heads of the terms.
The idea behind disabling \(\delta\) is that when comparing two constants
we hope not to have to unfold them if they already are the same.
\[
  \infer
    {
      u_1 \cong u_2 \\
      \convargs{\Ga}{\const\ k\ u_1}{\pi_1}{\const\ k\ u_2}{\pi_2}{\ayes}
    }
    {\convterm{\Ga}{\const\ k\ u_1}{\pi_1}{\const\ k\ u_2}{\pi_2}{\ayes}}
  %
\]
where \(\const\ k\ u\) refers to the constant of name \(k\) and universe
instance \(u\).
Here we first compare the universe instances to check that they are equal
(which is a bit more general that syntactic equality), and if so we compare
the stacks, or more specifically the arguments on those. I will explain this
part when presenting the corresponding function.
\marginnote[0.1cm]{
  One or the two of them might refer to axioms and in that case, we only unfold
  those that can be, and if we compare two axioms, we know they are distinct.
}
If the constant names aren't the same, or if the universe instances do not match
or if the argument comparison fails, we then unfold one of the constants and
compare them again.
\marginnote[1cm]{
  I informally write \(t_2[u_2]\) to mean \(t_2\) instantiated by \(u_2\).
}
\[
  \infer
    {
      (k_2 := t_2) \in \Sigma \\
      \convred{\Ga}{\const\ k_1\ u_1}{\pi_1}{t_2[u_2]}{\pi_2}{A}
    }
    {\convterm{\Ga}{\const\ k_1\ u_1}{\pi_1}{\const\ k_2\ u_2}{\pi_2}{A}}
  %
\]

Another interesting case is the comparison of \(\lambda\)-abstractions.
\marginnote[1cm]{
  Once again I show the rule when there are successes in each recursive calls,
  all the others yield errors.
}
\[
  \infer
    {
      \convred
        {\Ga}
        {A_1}
        {\stack{\lambda (x:\shole).\ t_1} :: \pi_1}
        {A_2}
        {\stack{\lambda (x:\shole).\ t_2} :: \pi_2}
        {\ayes}
      \\
      \convred
        {\Ga}
        {t_1}
        {\stack{\lambda (x:A_1).\ \shole} :: \pi_1}
        {t_2}
        {\stack{\lambda (x:A_2).\ \shole} :: \pi_2}
        {A}
    }
    {
      \convterm
        {\Ga}
        {\lambda (x:A_1).\ t_1}{\pi_1}
        {\lambda (x:A_2).\ t_2}{\pi_2}
        {A}
    }
  %
\]
First we compare the two domains and then we compare the two bodies.
This may seem like a simple case of recursing in the subterms but there is a
subtlety: the context when comparing the bodies is still \(\Ga\) and not
\(\Ga, x:A_1\) or \(\Ga, x:A_2\).
\marginnote[0.1cm]{
  A \emph{good} things that helps us complete proofs.
}
This is actually a good thing that we don't have to pick one of them and remain
symmetric.
We are saved by the stacks once more. Indeed, in
\(\stack{\lambda (x:A_1).\ \shole}\) we have the information corresponding to
\(x : A_1\). More generally, stacks do not only yield positions but also
contexts. In the expression
\[
  \isconv{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}
\]
\(t_1\) lives in \(\Ga, \stackctx\ \pi_1\), and \(t_2\) in
\(\Ga, \stackctx\ \pi_2\).

Other than those, we also deal with \(\Pi\)-types, pattern-matching,
projections, fixed- and cofixed-points.
The case of two applications is imposibble because the arguments would have been
pushed on the stacks.
If the terms do not fall in this diagonal, we instead call the fallback
function recursively.
\[
  \infer
    {\convfall{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
    {\convterm{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
  %
\]

\subsection{\mintinline{coq}{Args}}

When the two terms are convertible, it is time to move on the comparison of the
stacks, or rather the comparision of the leading arguments on said stacks.

A stack \(\pi\) can be decomposed into a list of arguments \(u_1, \dots, u_n\)
and a remaining stack \(\rho\) that does not start with some \(\coapp{u}\),
such that
\[
  \pi = \coapp{u_1} :: \dots :: \coapp{u_n} :: \rho
\]
With two such decomposed stacks, the meaning of the \mintinline{coq}{Args}
function is the following
\marginnote[1cm]{
  Notice how we have \(n\) arguments on both sides, if there is a mismatch,
  the function will return an error.
}
\[
  \footnotesize
  \infer
    {
      \convred
        {\Ga}
        {u_1}
        {\stack{t_1\ \shole\ u_2\ \dots u_n} :: \rho_1}
        {v_1}
        {\stack{t_2\ \shole\ v_2\ \dots v_n} :: \rho_2}
        {\ayes}
      \\\\
      \vdots \\\\
      \convred
        {\Ga}
        {u_n}
        {\stack{t_1\ u_1\ \dots u_{n-1}\ \shole} :: \rho_1}
        {v_n}
        {\stack{t_2\ v_1\ \dots v_{n-1}\ \shole} :: \rho_2}
        {\ayes}
    }
    {
      \convargs
        {\Ga}
        {t_1}
        {\coapp{u_1} :: \dots :: \coapp{u_n} :: \rho_1}
        {t_2}
        {\coapp{v_1} :: \dots :: \coapp{v_n} :: \rho_2}
        {A}
    }
  %
\]
Assuming that \(\Ga \vdash u_1 \equiv u_2\), it saying `yes' means that
\[
  \Ga \vdash t_1\ u_1\ \dots\ u_n \equiv t_2\ v_1\ \dots\ v_n
\]
(and also the stronger property that each \(u_i\) is convertible to \(v_i\) but
the property above is sufficient for our needs).

\subsection{\mintinline{coq}{Fallback}}

The fallback deals with terms outside of the diagonal that are potentially
stuck because of definitions that are not unfolded.
It tries to make progress on each side before resorting to plain and simple
syntactic equality.
\marginnote[1cm]{
  I use \(\red_\WM \not =\) to mean that the reduction produced a different term.
  In the formalisation its a different process that checks that the term is
  indeed stuck because of \(\delta\).
}
\marginnote[4.4cm]{
  Here \(t_1 = t_2\) means that \(t_1\) and \(t_2\) have been checked to be
  syntactically equal, up to universes.
}
\begin{mathpar}
  \infer
    {
      \Ga \vdash \vscmd{t_1}{\pi_1} \red_\WM \not= \vscmd{u}{\rho} \\
      \convterm{\Ga}{u}{\rho}{t_2}{\pi_2}{A}
    }
    {\convfall{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
  %

  \infer
    {
      \Ga \vdash \vscmd{t_2}{\pi_2} \red_\WM \not= \vscmd{u}{\rho} \\
      \convterm{\Ga}{t_1}{\pi_1}{u}{\rho}{A}
    }
    {\convfall{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
  %

  \infer
    {
      t_1 = t_2 \\
      \convargs{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}
    }
    {\convfall{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}}
  %
\end{mathpar}

\subsection{About cumulativity and universes}

In the (partial) definitions above I sometimes refer to syntactic equality of
terms or equality of universes. These are alaways refering to the universe
constraints to be decided, \ie their respective representations need not be the
same on both sides of the equality. This is the reason why I write \(u = v\)
when I could have unified them, the way I unified \(k_1\) and \(k_2\) into \(k\)
when considering constants.

Another important point is that we actually define conversion and cumulativity
at the same time, using an extra argument (essentially a boolean) telling us
which of those we are checking for.
I did everything in the setting of conversion to have lighter notations, but
everything works just as well with cumulativity.

I will not explain how we specify and check equality or cumulativity of
universes as it was not my own contribution.
The interested reader should refer either to~\sidecite{sozeau2019coq} or the
formalisation.

\section{Termination and correctness}

\subsection{Specification}

You will perhaps find my presentation surprising in that I didn't even specify
what was expected of the algorithm I was showing. I wanted to focus on the
intuition before going into these details.
It is time to correct this slight.

All the `judgements' I presented earlier, that is
\[
  \begin{array}{l}
    \convred{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A} \\
    \convterm{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A} \\
    \convargs{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A} \\
    \convfall{\Ga}{t_1}{\pi_1}{t_2}{\pi_2}{A}
  \end{array}
\]
are correct if, when they return \(\ayes\), we have
\[
  \Ga \vdash t_1\ u_1\ \dots\ u_n \equiv t_2\ v_1\ \dots\ v_n
\]
where \(\pi_1\) and \(\pi_2\) are decomposed as
\[
  \begin{array}{rcl}
    \pi_1 &=& \coapp{u_1} :: \dots :: \coapp{u_n} :: \rho_1 \\
    \pi_2 &=& \coapp{v_1} :: \dots :: \coapp{v_n} :: \rho_2
  \end{array}
\]
This might be a bit surprising that we only conclude on applications at the head
of the stakcs and not about the whole stacks themselves.
If we were asking for
\[
  \Ga \vdash \zip\ \vscmd{t_1}{\pi_1} \equiv \vscmd{t_2}{\pi_2}
\]
instead, it would be too strong a requirement. Indeed, in the case of
\(\lambda\)-abstractions, we consider the recrusive call on the domains
\marginnote[1cm]{
  Note that \(\zip\ \vscmd{A}{\stack{\lambda (x:\shole).t} :: \pi}\)
  is equal to \(\zip\ \vscmd{\lambda (x:A).t}{\pi}\).
}
\[
  \convred
    {\Ga}
    {A_1}
    {\stack{\lambda (x:\shole).\ t_1} :: \pi_1}
    {A_2}
    {\stack{\lambda (x:\shole).\ t_2} :: \pi_2}
    {\ayes}
\]
which we want to conclude on \(A_1\) and \(A_2\), not on the full term,
otherwise the recusrive call on the bodies becomes superfluous.
This, I think, is a sign, that this approach is doomed to fail.

Going back to the bigger picture, it is also not a problem that we conclude only
on a portion of the stack since the conversion algorithm will be called with
empty stacks at the start.
\marginnote[0.6cm]{
  As you can see we also call the \mintinline{coq}{Reduction} phase first as
  well.
}
\[
  \convred{\Ga}{t_1}{\varepsilon}{t_2}{\varepsilon}{A}
\]

We can now move on to the main difficulty regarding conversion: its termination.

\subsection{Termination}

\section{Future work: \(\eta\)-conversion}

\todo{how the implem deals with eta}