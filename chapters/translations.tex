% \setchapterpreamble[u]{\margintoc}
\chapter{Translations}
\labch{translations}

Syntactical translations are a special case of program transformations suited
for type theory, and a method of choice to get models of type theories.
This is better studied in Simon Boulier's thesis and next 700~\misref{} but in
order to keep this document self contained, I will do my best to give a
meaningful excerpt here.

\section{Syntactical translations}

\subsection{Definition}
\labsubsec{syn-trans-def}

A \emph{syntactical} translation, as the name suggests, operates on the syntax
of terms. It has a source theory \cS and a target theory \cT with possibly
different syntax and typing rules---though usually \cS is an extension of \cT,
more on that later.

A translation is then given as two functions:
\begin{itemize}
  \item \([.]\) taking \cS terms to \cT terms;
  \item \(\transl{.}\) taking \cS types to \cT types.
\end{itemize}
And \(\transl{.}\) is---often---canonically extended to contexts:
\[
\begin{array}{lcl}
  \transl{\ctxempty} &\coloneqq& \ctxempty \\
  \transl{\Ga, x : A} &\coloneqq& \transl{\Ga}, x : \transl{A}
\end{array}
\]
\marginnote[-2cm]{
  It's not always the case that the \(\transl{\ctxempty}\) is also the empty
  context, and sometimes one variable is translated to several, but in a lot of
  cases it can still be encoded that way.
}

Usually, \(\transl{.}\) is built using \([.]\) and sometimes corresponds
exactly to \([.]\).
The translation is often done in an homomorphic way.

There are two main properties expected of a translation: type preservation
and preservation of falsehood.

\begin{definition}[Type preservation]
  A translation \([.], \transl{.}\) is type preserving when
  \(\isterm{\Ga}{t}{A}\) implies \(\isterm{\transl{\Ga}}{[t]}{\transl{A}}\).
\end{definition}

\begin{definition}[Preservation of falsehood]
  A translation \([.], \transl{.}\) from \cS to \cT is said to preserve
  falsehood when the translation of the empty type implies falsehood in the
  target:
  \[ \vdash_\cT \transl{\bot_\cS} \to \bot_\cT \]
\end{definition}

If a translation satisfies both those properties, we can conclude consistency
of \cS relatively to \cT.

\begin{theorem}[Relative consistency]
  If there is a translation from \cS to \cT that preserves typing and
  falsehood, then the consistency of \cT implies that of \cS.
\end{theorem}

\begin{proof}
  Assume a translation \([.], \transl{.}\) from \cS to \cT that preserves typing
  and falsehood. We'll prove the contraposition and assume inconsistency in
  \cS, that is the existence of a term \(t\) such that
  \[ \vdash_\cS t : \bot_\cS \]
  By preservation of typing, we get
  \[ \vdash_\cT [t] : \transl{\bot_\cS} \]
  Moreover, since the translation preserves falsehood, there is a term \(f\)
  such that \(\vdash_\cT f : \transl{\bot_\cS} \to \bot_\cT\).
  Thus, we conclude, using application that
  \[ \vdash_\cT f\ t : \bot_\cT \]
  in other words that \cT is also inconsistent.
\end{proof}

Relative consistency is all the more interesting when the source theory is more
complex than the target and even more so when \cT is theory that we trust.

Type preservation can be achieved by proving intermediary properties:
substitutivity, preservation of reduction and of conversion.

\begin{definition}[Substitutivity]
  A translation \([.], \transl{.}\) is substitutive when
  \[
    \begin{array}{lcl}
      [t\{x \sto u\}] &\coloneqq& [t]\{x \sto [u]\} \\
      \transl{A\{x \sto u\}} &\coloneqq& \transl{A}\{x \sto [u]\} \\
    \end{array}
  \]
\end{definition}

\begin{definition}[Preservation of reduction]
  A translation \([.], \transl{.}\) is said to preserve reduciton when
  \(u \red v\) implies \([u] \red [v]\) (and \(\transl{u} \red \transl{v}\)).
\end{definition}

\begin{definition}[Preservation of conversion]
  A translation \([.], \transl{.}\) is said to preserve reduciton when
  \(u \equiv v\) implies \([u] \equiv [v]\)
  (and \(\transl{u} \equiv \transl{v}\)).
\end{definition}

\subsection{Example: the \(\times\ \mathsf{bool}\) translation}

A simple yet non-trivial example of translation (or class of translations) is
the so-called \(\times\ \mathsf{bool}\) translation, again from~\misref.

As we said earlier, the source is going to be an extension of the target.
We'll keep the target pretty basic as a simple instance of \acrshort{ITT}
with a hierarchy of universes \(\Ty{i}\) (for \(i \in \mathbb{N}\)) with the
following rules:
\begin{itemize}
  \item \((\Ty{i}, \Ty{j}) \in \Ax\) for \(i \le j\);
  \item \((\Ty{i}, \Ty{j}, \Ty{k}) \in \Rl\) for \(i, j \le k\).
\end{itemize}
\marginnote[-2cm]{
  Refer to \frefsubsec{pts-itt} to see what theory we extend here.
}
Otherwise it has to feature a boolean type \(\bool\)---with the usual \(\ttrue\)
and \(\ffalse\)---product types \(A \times B\) as special
cases\sidenote{See \frefsec{inductive-types}.} of \(\Sigma\)-types,
and equality.
%
\begin{mathpar}
  \infer
    { }
    {\isterm{\Ga}{\bool}{\Ty{0}}}
  %

  \infer
    { }
    {\isterm{\Ga}{\ttrue}{\bool}}
  %

  \infer
    { }
    {\isterm{\Ga}{\ffalse}{\bool}}
  %
\end{mathpar}

The source is going to be the target extended with a new principle corresponding
to the negation of \acrlong{funext}, that is the existence of two functions
extensionaly equal, but not equal themselves.
%
\[
  \infer
    { }
    {
      \isterm
        {\Ga}
        {\notfunext}
        {\Sigma\ A\ B\ (f\ g : A \to B).\
          (\forall x.\ f\ x = g\ x) \times f \not= g
        }
    }
  %
\]
\marginnote[-1.4cm]{
  Inequality \(x \not= y\) is defined as the negation of equality, that is a map
  to the empty type: \(x = y \to \bot\).
}
%
We will write \(\Notfunext\) for the type of \(\notfunext\) in the following.

The idea is to inhabit this extra principle in the target which does not feature
it, or rather to inhabit its translation \(\transl{\Notfunext}\).
In order to differentiate functions of the target, while keeping them
observationally equal, we translate them by adding a boolean label to them.
Basically \(\lambda x. x\) is sent to \((\lambda x. x, \ttrue)\), the \(\ttrue\)
telling us the it might have come from the translation. Any function coming with
\(\ffalse\) instead will not be a translated term.

The translation is defined as follows:
%
\[
\begin{array}{lcl}
  [ x ] &\coloneqq& x \\ \relax
  [ \lambda (x : A).\ t ] &\coloneqq& (\lambda (x : \transl{A}).\ [t],\ttrue) \\
  \relax
  [ t\ u ] &\coloneqq& [t]\ [u] \\ \relax
  [ (u, v) ] &\coloneqq& ([u], [v]) \\ \relax
  [ p.1 ] &\coloneqq& [p].1 \\ \relax
  [ p.2 ] &\coloneqq& [p].2 \\ \relax
  [ \ttrue ] &\coloneqq& \ttrue \\ \relax
  [ \ffalse ] &\coloneqq& \ffalse \\ \relax
  [ \tif{t}{b. P}{u}{v} ] &\coloneqq& \tif{[t]}{b. \transl{P}}{[u]}{[v]} \\
  \relax
  [ \refl{A} u ] &\coloneqq& \refl{\transl{A}} [u] \\ \relax
  [ \J{A}{u}{x.e.P}{w}{v}{p} ] &\coloneqq&
  \J{\transl{A}}{[u]}{x.e.\transl{P}}{[w]}{[v]}{[p]} \\ \relax
  [ \Ty{i} ] &\coloneqq& \Ty{i} \\ \relax
  [ \Pi (x : A).\ B ] &\coloneqq&
  (\Pi (x : \transl{A}).\ \transl{B}) \times \bool \\ \relax
  [ \Sigma (x : A).\ B ] &\coloneqq& \Sigma (x:\transl{A}).\ \transl{B} \\
  \relax
  [ \bool ] &\coloneqq& \bool \\ \relax
  [ u =_A v ] &\coloneqq& [u] =_{\transl{A}} [v] \\ \relax
  \\
  \transl{A} &\coloneqq& [A]
\end{array}
\]
\marginnote[-0.6cm]{Notice how \(\transl{.}\) is just defined as \([.]\).}

I actually didn't provide the full translation here since I \emph{forgot}
the definition of \([\notfunext]\).
Writing down the term is rather tedious and boring, so instead I will give an
argument as to why it exists: you can provide any type for \(A\) and \(B\), for
instance \(\Ty{0}\) and then the for \(f\) and \(g\) we give
\((\lambda (x:\Ty{0}).\ x, \ttrue)\) and
\((\lambda (x:\Ty{0}).\ x, \ffalse)\) that will be pointwise equal (after
suffering the first projection) but different nonetheless.

This translation satisfies all the properties I mentioned in
\nrefsubsec{syn-trans-def}, including preservation of typing and of falsehood.
As such it shows that the negation of \acrshort{funext} is consistent in
\acrshort{ITT}. On the other hand, it can be shown that \acrshort{funext} is
also consistent, and as such independent from \acrshort{ITT}.
\reminder[-2.7cm]{Independence}{
  A proposition \(P\) is \emph{independent} from a theory \cT when both
  \(\cT + P\) and \(\cT + \neg P\) are consistent relatively to \cT.
}
For details, you should again refer to
\sidecite{boulier17:next-syntac-model-type-theor,boulier2018extending}
which gives a more comprehensive treatment of this and other translations.

\section{Other translations}

\todo{On derivations or intermediary representations}
\todo{Digression on notion of proof again?}

\section{Conversative extensions}